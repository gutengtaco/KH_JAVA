package com.kh.chap02_abstractAndInterface.part02_family.model.vo;

//	인터페이스 작성
//	인터페이스는 클래스의 일종임
public interface Basic {	// 사람이라면 당연히 해야하는 행동들을 정의만 해둔 인터페이스(먹기, 자기)
	/*
	 * 인터페이스
	 * 상수필드와 추상메소드들로만 이루어진 추상클래스의 변형체
	 * 
	 * [표현법]
	 * 접근제한자		interface 이름 {		
	 * (public, default(생략))
	 *
	 * 	// 필드부 => 상수필드만 작성
	 *  
	 * 	// 메소드부 => 추상메소드만 작성
	 * 
	 *  }
	 * 인터페이스에서는 무조건 필드는 "상수필드"로만 작성해야함.
	  *인터페이스에서는 무조건 메소드는 "추상메소드"로만 작성해야함. 
	 * => 무조건 내가 구현해야 할 것이 있으면, 인터페이스를 만들어 상속시켜주면 됨.
	 * => 추상클래스보다 더 강한 규칙성, 통일성, 강제성을 가지는 것이 인터페이스임.
	 * => 특이하게, 다중상속이 허용됨.
	 *  ex) Parent 	---------┐
	 * 						 │	
	 *  	Person	---->	Mother
	 *  
	 *  					Baby
	 * (결국 인터페이스는 메소드에 대한 정의만을 하고 있어서,
	 * 메소드의 이름이 겹치더라도, 최종적인 구현 부분은 구현 클래스에서 이루어지기때문에.
	 * 추가적으로, 필드의 경우는 static이 붙기 때문에, 명시적으로 어디서 온 것인지 구분이 가능함.)
	 * public static final XXX;
	 *
	 * 추상클래스와 인터페이스의 비교
	 * 1. 공통점
	 * - 둘다 미완성된 상태이므로, 객체 생성이 불가함.
	 * - 단,참조형 변수로써 선언은 가능함. => 이를 바탕으로, 다형성을 적용하여 값을 대입 가능.
	 * - 상속(구현)하는 클래스(자식)에 추상메소드들을 구현하도록 강제함.
	 * 
	 * 2. 차이점
	 * 추상클래스의 경우는 클래스 내에 일반필드, 일반메소드를 정의할 수 있지만, 
	 * 인터페이스의 경우는 애초부터 모든 필드가 상수필드, 모든 메소드가 추상메소드로만 정의해야함.
	 * 
	 * 추상클래스의 경우는 추상클래스를 상속받아서 기능을 더 이용하고, 확장시키는데 목적임.
	 * 반면, 인터페이스는 클래스의 기능(메소드) 구현을 강제하기 위한 목적으로 사용.
	 * =>즉, 기능구현을 강제함으로 구현 객체의 같은 동작을 보장할 수 있음 + 적어도 자식들한테는 그 메소드들이 무조건 있어야 함.
	 * 
	 * extends(확장시키다) vs implements(구현하다)
	 * - 클래스간에  상속관계일때 : 자식클래스명 extends 부모클래스명
	 * - 클래스와 인터페이스의 상속관계일때 == 구현관계일때 : 자식클래스명 implements 인터페이스명 
	 * - 인터페이스간에 상속관계일때 : 자식인터페이스명 extends 부모인터페이스명, 부모인터페이스명2(다중상속이 가능함)
	 */
	
//	필드부 => 상수필드
//	public static final 자료형 변수명 = 값;
	/*public static final*/ int NUM = 10;  // 인터페이스가 상수필드만 정의할 수 있기때문에 생략가능
	
//	메소드부 => 추상메소드(abstract)
	/*public abstract*/ void eat();		// 마찬가지로, 인터페이스가 추상메소드만 정의할 수 있기때문에 생략가능
	/*public abstract*/ void sleep();
}
